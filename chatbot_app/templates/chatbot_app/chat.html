{% extends "chatbot_app/base.html" %}

{% block title %}Chat Session #{{ current_session.id }} - AI for Insights{% endblock %}

{% block page_title %}{% endblock %}

{% block content %}
<style>
    /* Override content-body padding for chat page */
    .content-body {
        padding: 0 !important;
    }
    
    .chat-container {
        background: #FDFDF8;
        height: 100vh;
        display: flex;
        flex-direction: column;
        width: 100%;
        margin: 0;
    }
    
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 24px;
        background: #FDFDF8;
    }
    
    .message {
        margin-bottom: 16px;
        padding: 8px 12px;
        border-radius: 8px;
        max-width: fit-content;
        word-break: break-word;
        position: relative;
        display: inline-block;
    }
    
    .message-user {
        background: #140F0F;
        color: #FDFDF8;
        margin-left: auto;
        border-bottom-right-radius: 4px;
        border: 1px solid #140F0F;
        max-width: 70%;
    }
    
    .message-bot {
        background: #EFEEEC;
        color: #140F0F;
        margin-right: auto;
        border-bottom-left-radius: 4px;
        border: 1px solid #C8C2B8;
        max-width: 70%;
    }
    
    .user {
        font-weight: 600;
        color: #2B1F1E;
        font-size: 0.85rem;
        margin-bottom: 4px;
    }
    
    .bot {
        font-weight: 600;
        color: #2B1F1E;
        font-size: 0.85rem;
        margin-bottom: 4px;
    }
    
    .message-content {
        line-height: 1.5;
        font-size: 0.95rem;
    }
    
    .chat-input-container {
        padding: 20px 24px;
        background: #FDFDF8;
        border-top: 1px solid #C8C2B8;
        margin-top: auto;
    }
    
    .chat-form {
        display: flex;
        gap: 12px;
        align-items: center;
    }
    
    .chat-input {
        flex: 1;
        padding: 12px 16px;
        border: 1px solid #C8C2B8;
        border-radius: 6px;
        font-size: 0.95rem;
        transition: border-color 0.15s ease;
        outline: none;
        background: #FDFDF8;
        color: #140F0F;
    }
    
    .chat-input:focus {
        border-color: #140F0F;
        box-shadow: 0 0 0 0.2rem rgba(20, 15, 15, 0.1);
    }
    
    .send-btn {
        padding: 12px 20px;
        background: #FF4646;
        color: #FDFDF8;
        border: none;
        border-radius: 6px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .send-btn:hover {
        background: #E63946;
        transform: none;
    }
    
    .empty-msg {
        text-align: center;
        color: #7F746C;
        padding: 40px 20px;
        font-style: italic;
    }
    
    .cursor {
        animation: blink 1s infinite;
    }
    
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
    
    .message-container {
        margin-bottom: 16px;
        display: flex;
        flex-direction: column;
    }
    
    .message-container .message-user {
        align-self: flex-end;
    }
    
    .message-container .message-bot {
        align-self: flex-start;
    }
    
    .feedback-buttons {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        justify-content: flex-start;
        padding: 0 16px;
    }
    
    .feedback-btn {
        background: none;
        border: 1px solid #7F746C;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.15s ease;
        opacity: 0.7;
        position: relative;
    }
    
    .feedback-btn:hover {
        opacity: 1;
        background: #EFEEEC;
    }
    
    .like-btn:hover {
        background: #EFEEEC;
        border-color: #140F0F;
        color: #140F0F;
    }
    
    .dislike-btn:hover {
        background: #EFEEEC;
        border-color: #140F0F;
        color: #140F0F;
    }
    
    .feedback-btn.active {
        opacity: 1;
        transform: scale(1.05);
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        font-weight: bold;
        transition: all 0.3s ease;
    }
    
    .faq-btn {
        background: #C8C2B8;
        color: #140F0F;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.15s ease;
        margin-left: 8px;
    }
    
    .faq-btn:hover {
        background: #140F0F;
        color: #FDFDF8;
        transform: none;
    }
    
    .faq-btn:active {
        transform: none;
    }
    
    .like-btn.active {
        background: #EFEEEC;
        border-color: #140F0F;
        color: #140F0F;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(20, 15, 15, 0.2);
    }
    
    .dislike-btn.active {
        background: #EFEEEC;
        border-color: #140F0F;
        color: #140F0F;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(20, 15, 15, 0.2);
    }
    
    /* Markdown styles */
    .message-content h1, .message-content h2, .message-content h3, 
    .message-content h4, .message-content h5, .message-content h6 {
        margin: 16px 0 8px 0;
        color: #140F0F;
        font-weight: 600;
    }
    
    .message-content h1 { font-size: 1.4rem; }
    .message-content h2 { font-size: 1.2rem; }
    .message-content h3 { font-size: 1.1rem; }
    
    .message-content p {
        margin: 8px 0;
        line-height: 1.6;
    }
    
    .message-content ul, .message-content ol {
        margin: 8px 0;
        padding-left: 20px;
    }
    
    .message-content li {
        margin: 4px 0;
        line-height: 1.5;
    }
    
    .message-content blockquote {
        border-left: 4px solid #3182ce;
        margin: 12px 0;
        padding: 8px 12px;
        background: #f8fafc;
        border-radius: 0 4px 4px 0;
        color: #4a5568;
    }
    
    .message-content code {
        background: #f1f5f9;
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.9em;
    }
    
    .message-content pre {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 12px;
        overflow-x: auto;
        margin: 12px 0;
    }
    
    .message-content pre code {
        background: none;
        padding: 0;
    }
    
    .message-content table {
        border-collapse: collapse;
        width: 100%;
        margin: 12px 0;
        background: #fff;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .message-content table th {
        background: #f8fafc;
        padding: 8px 12px;
        text-align: left;
        font-weight: 600;
        color: #2d3748;
        border-bottom: 2px solid #e2e8f0;
        border-right: 1px solid #e2e8f0;
    }
    
    .message-content table th:last-child {
        border-right: none;
    }
    
    .message-content table td {
        padding: 8px 12px;
        border-bottom: 1px solid #e2e8f0;
        border-right: 1px solid #e2e8f0;
        color: #4a5568;
    }
    
    .message-content table td:last-child {
        border-right: none;
    }
    
    .message-content table tr:hover {
        background: #f7fafc;
    }
    
    .message-content hr {
        border: none;
        border-top: 1px solid #e2e8f0;
        margin: 16px 0;
    }
    
    .message-content strong {
        font-weight: 600;
    }
    
    .message-content em {
        font-style: italic;
    }
    
    .markdown-content {
        line-height: 1.6;
    }
    
    .markdown-content > *:first-child {
        margin-top: 0;
    }
    
    .markdown-content > *:last-child {
        margin-bottom: 0;
    }
    
    /* Expandable code blocks */
    .code-block {
        margin: 12px 0;
        border: 1px solid #140F0F;
        border-radius: 8px;
        overflow: hidden;
        background: #f8fafc;
        display: none; /* Hidden by default */
    }
    
    .code-block.show {
        display: block; /* Visible when toggled */
    }
    

    
    .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: #f1f5f9;
        border-bottom: 1px solid #e2e8f0;
    }
    
    .code-language {
        font-size: 0.8rem;
        font-weight: 600;
        color: #64748b;
        text-transform: uppercase;
    }
    

    
    .code-content {
        background: #f7fafc;
        border-top: 1px solid #e2e8f0;
    }
    
    /* Code toggle container and button styles */
    .code-toggle-container {
        margin: 12px 0 0 0;
        text-align: right;
        padding-right: 16px;
    }
    
    .code-toggle-btn {
        background: #140F0F;
        color: white;
        border: 1px solid #140F0F;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
    }
    
    .code-toggle-btn:hover {
        background: #2a2522;
        border-color: #2a2522;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(20, 15, 15, 0.3);
    }
    
    .code-toggle-btn:active {
        transform: translateY(0);
        background: #140F0F;
        border-color: #140F0F;
    }
    

    
    .code-content pre {
        margin: 0;
        background: none;
        border: none;
        padding: 12px;
    }
    
    /* LaTeX formula styles */
    .message-content .katex {
        font-size: 1.1em;
        margin: 12px 0;
    }
    
    .message-content .katex-display {
        margin: 16px 0;
        text-align: center;
    }
    
    /* JSON Response Styles */
    .json-response-container {
        background: #f8fafe;
        border: 1px solid #d1d5db;
        border-radius: 12px;
        padding: 16px;
        margin: 16px 0;
    }
    
    .json-section {
        margin-bottom: 24px;
        background: #ffffff;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
        overflow: hidden;
    }
    
    .json-section:last-child {
        margin-bottom: 0;
    }
    
    .section-title {
        background: #f3f4f6;
        padding: 12px 16px;
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #374151;
        border-bottom: 1px solid #e5e7eb;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
    }
    
    .section-content {
        padding: 16px;
    }
    
    .section-content p {
        margin: 0;
        line-height: 1.6;
        color: #4b5563;
    }
    
    .steps-list {
        margin: 0;
        padding-left: 20px;
    }
    
    .steps-list li {
        margin: 8px 0;
        line-height: 1.6;
        color: #4b5563;
    }
    
    .definitions-list {
        margin: 0;
        padding-left: 20px;
        list-style-type: disc;
    }
    
    .definitions-list li {
        margin: 12px 0;
        line-height: 1.6;
        color: #4b5563;
        font-size: 0.95rem;
    }
    
    .math-formula {
        margin: 16px 0;
        text-align: center;
        background: #f9fafb;
        padding: 16px;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
    }
    
    .formula-error {
        color: #dc2626;
        font-family: monospace;
        font-size: 0.9rem;
        background: #fef2f2;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #fecaca;
    }
    
    .table-container {
        overflow-x: auto;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
    }
    
    .table-container table {
        width: 100%;
        border-collapse: collapse;
        margin: 0;
    }
    
    .table-container th {
        background: #f3f4f6;
        padding: 12px;
        text-align: left;
        font-weight: 600;
        color: #374151;
        border-bottom: 2px solid #e5e7eb;
    }
    
    .table-container td {
        padding: 12px;
        border-bottom: 1px solid #e5e7eb;
        color: #4b5563;
    }
    
    .table-container tr:last-child td {
        border-bottom: none;
    }
    
    .table-container tr:hover {
        background: #f9fafb;
    }
    
    .code-copy-btn {
        background: #6b7280;
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .code-copy-btn:hover {
        background: #4b5563;
    }
    
    .auto-plot-display {
        margin-top: 16px;
        padding: 16px;
        background: #f9fafb;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
    }
    
    .plot-title {
        font-weight: 600;
        color: #374151;
        margin-bottom: 12px;
        font-size: 1rem;
    }
    
    .plot-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
    }
    
    .download-plot-btn {
        background: #10b981;
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    
    .download-plot-btn:hover {
        background: #059669;
    }
    
    .plot-error {
        margin-top: 16px;
        padding: 12px 16px;
        background: #fef2f2;
        border: 1px solid #fecaca;
        border-radius: 6px;
        color: #dc2626;
    }
    
    .error-details {
        margin-top: 12px;
    }
    
    .error-details summary {
        cursor: pointer;
        font-weight: 600;
        color: #b91c1c;
        padding: 8px 0;
    }
    
    .error-details summary:hover {
        color: #dc2626;
    }
    
    .debug-output {
        margin-top: 8px;
        padding: 12px;
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 4px;
        font-family: monospace;
        font-size: 0.85rem;
    }
    
    .debug-output h4 {
        margin: 0 0 8px 0;
        color: #374151;
        font-size: 0.9rem;
    }
    
    .debug-output pre {
        margin: 0;
        background: #ffffff;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        overflow-x: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    /* NEW STYLES FOR RESTRUCTURED LAYOUT */
    
    /* Plot section specific styles */
    .plot-section .section-content {
        padding: 16px;
    }
    
    .header-copy-btn {
        background: #140F0F;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
    }
    
    .header-copy-btn:hover {
        background: #2a2522;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(20, 15, 15, 0.3);
    }
    
    .header-copy-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    /* Table section specific styles */
    .table-section .section-content {
        padding: 16px;
    }
    
    /* Table toggle container - like error divider style */
    .table-toggle-container {
        cursor: pointer;
        margin: 8px 0 0 0;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f8f9fa;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        transition: all 0.2s;
    }
    
    .table-toggle-container:hover {
        background: #f1f3f4;
        border-color: #d1d5db;
    }
    
    .table-toggle-text {
        font-size: 13px;
        color: #6b7280;
        font-weight: 500;
        transition: color 0.2s;
    }
    
    .table-toggle-container:hover .table-toggle-text {
        color: #374151;
    }
    

    
    /* Tab bar styles for combined information section */
    .tab-bar {
        display: flex;
        border-bottom: 2px solid #e5e7eb;
        margin-bottom: 20px;
    }
    
    .tab-btn {
        background: none;
        border: none;
        padding: 12px 20px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        color: #6b7280;
        border-bottom: 3px solid transparent;
        transition: all 0.2s;
        margin-right: 8px;
    }
    
    .tab-btn:hover {
        color: #374151;
        background: #f9fafb;
    }
    
    .tab-btn.active {
        color: #4f46e5;
        border-bottom-color: #4f46e5;
        background: #f8faff;
    }
    
    .tab-contents {
        min-height: 200px;
    }
    
    .tab-content {
        animation: fadeIn 0.3s ease-in;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    /* Remove margin from section titles to clean up spacing */
    .json-section .section-title {
        margin-top: 0;
        margin-bottom: 16px;
        color: #1f2937;
        font-weight: 600;
        font-size: 18px;
    }
    
    /* Ensure proper spacing between sections */
    .json-section {
        margin-bottom: 32px;
    }
    
    .json-section:last-child {
        margin-bottom: 0;
    }
    
    /* Python execution styles */
    .python-execution {
        margin-top: 12px;
        padding: 12px;
        background: #f8fafc;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
    }
    
    .execute-python-btn {
        background: #3182ce;
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .execute-python-btn:hover:not(:disabled) {
        background: #2c5aa0;
    }
    
    .execute-python-btn:disabled {
        opacity: 0.7;
        cursor: not-allowed;
    }
    
    .execution-result {
        margin-top: 12px;
    }
    
    .plot-container {
        margin-bottom: 12px;
    }
    
    .plot-display {
        text-align: center;
    }
    
    .download-plot-btn {
        background: #38a169;
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        margin-top: 8px;
        transition: all 0.2s ease;
    }
    
    .download-plot-btn:hover {
        background: #2f855a;
    }
    
    .execution-output {
        margin-top: 12px;
    }
    
    .stdout {
        background: #f0fff4;
        border: 1px solid #c6f6d5;
        border-radius: 6px;
        padding: 8px 12px;
        margin-bottom: 8px;
    }
    
    .stderr {
        background: #fed7d7;
        border: 1px solid #feb2b2;
        border-radius: 6px;
        padding: 8px 12px;
        margin-bottom: 8px;
    }
    
    .error {
        color: #e53e3e;
        font-weight: 500;
    }
    
    .loading {
        color: #718096;
        font-style: italic;
    }
    
    /* Automatic plot display styles */
    .auto-plot-display {
        margin-top: 16px;
        padding: 16px;
        background: #f8fafc;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
    }
    
    .plot-title {
        font-weight: 600;
        color: #2d3748;
        margin-bottom: 12px;
        font-size: 1rem;
    }
    
    .plot-error {
        margin-top: 16px;
        padding: 12px;
        background: #fed7d7;
        border: 1px solid #feb2b2;
        border-radius: 8px;
    }
    
    /* Error message styles */
    .error-message {
        background: #fef2f2;
        border: 2px solid #fecaca;
        border-radius: 8px;
        padding: 16px;
        margin: 16px 0;
        color: #dc2626;
    }
    
    .error-message h4 {
        margin: 0 0 12px 0;
        color: #b91c1c;
        font-size: 1.1rem;
    }
    
    .error-message p {
        margin: 8px 0;
        line-height: 1.5;
    }
    
    .error-message ul {
        margin: 8px 0;
        padding-left: 20px;
    }
    
    .error-message li {
        margin: 4px 0;
        line-height: 1.4;
    }
    
    .error-message pre {
        background: #ffffff;
        border: 1px solid #f87171;
        border-radius: 4px;
        padding: 12px;
        margin: 8px 0;
        font-size: 0.9rem;
        overflow-x: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
    }
    
    .error-message details {
        margin: 12px 0;
    }
    
    .error-message summary {
        cursor: pointer;
        font-weight: 600;
        padding: 8px 0;
        color: #b91c1c;
    }
    
    .error-message summary:hover {
        color: #dc2626;
    }
</style>

<div class="chat-container">
    <div class="chat-messages" id="chat-messages">
        {% if chat_history %}
            {% for message in chat_history %}
                <div class="message-container">
                    <div class="message message-{{ message.sender }}">
                        <div class="message-content">
                            {% if message.sender == 'bot' %}
                                {% if 'json-section' in message.text or 'json-response-container' in message.text %}
                                    <div class="json-response-container">{{ message.text|safe }}</div>
                                {% else %}
                                    <div class="markdown-content" data-text="{{ message.text|escapejs }}" data-message-id="{{ message.id }}">{{ message.text|linebreaks }}</div>
                                {% endif %}
                            {% else %}
                                {{ message.text|linebreaks }}
                            {% endif %}
                        </div>
                    </div>
                    {% if message.sender == 'bot' %}
                        <div class="feedback-buttons" data-message-id="{{ message.id }}">
                            <button class="feedback-btn like-btn" onclick="submitFeedback('like', '{{ current_session.id }}', '{{ message.id }}', event)" title="Like this response (click again to remove)">
                                👍
                            </button>
                            <button class="feedback-btn dislike-btn" onclick="submitFeedback('dislike', '{{ current_session.id }}', '{{ message.id }}', event)" title="Dislike this response (click again to remove)">
                                👎
                            </button>
                            <button class="faq-btn" onclick="addToFAQ('{{ current_session.id }}', '{{ message.id }}', event)" title="Add this conversation to FAQ" data-session-id="{{ current_session.id }}">
                                Add to FAQ
                            </button>
                        </div>
                    {% endif %}
                </div>
            {% endfor %}
        {% else %}
            <div class="empty-msg">No messages yet. Start the conversation!</div>
        {% endif %}
    </div>
    
    <div class="chat-input-container">
        <form class="chat-form" id="chat-form">
            <input type="text" 
                   class="chat-input" 
                   id="user-input" 
                   placeholder="Type your message..." 
                   autocomplete="off" />
            <button type="submit" class="send-btn">Send</button>
        </form>
    </div>
</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script>
// Configure marked.js for markdown rendering
marked.setOptions({
    breaks: true,
    gfm: true, // GitHub Flavored Markdown
    tables: true,
    sanitize: false,
    headerIds: false,
    mangle: false
});



const chatForm = document.getElementById('chat-form');
const chatMessages = document.getElementById('chat-messages');
const userInput = document.getElementById('user-input');
const sessionId = "{{ current_session.id }}";

// Auto-scroll to bottom
function scrollToBottom() {
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Initial scroll
scrollToBottom();

// Chat form submit logic
chatForm.onsubmit = async function(e) {
    e.preventDefault();
    const message = userInput.value.trim();
    if (!message) return;
    
    // Show user message immediately
    chatMessages.innerHTML += `
        <div class="message-container">
            <div class="message message-user">
                <div class="message-content">${message}</div>
            </div>
        </div>
    `;
    userInput.value = '';
    scrollToBottom();
    
    // Show streaming message from bot
    const streamingId = `streaming-${Date.now()}`;
    chatMessages.innerHTML += `
        <div class="message-container">
            <div class="message message-bot" id="${streamingId}">
                <div class="message-content">
                    <div class="streaming-content"></div>
                </div>
            </div>
        </div>
    `;
    scrollToBottom();
    
    // Start streaming
    try {
        // Add timeout to the fetch request
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 600000); // 10 minutes timeout
        
        const response = await fetch("{% url 'dify_streaming_proxy' %}", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({message, session_id: sessionId}),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        // Check if response is ok
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const streamingElem = document.getElementById(streamingId);
        if (!streamingElem) return;
        
        const streamingContent = streamingElem.querySelector('.streaming-content');
        let fullReply = "";
        let hasError = false;
        
        // Handle streaming response
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));
                        
                        if (data.type === 'chunk') {
                            // Stream the chunk to the UI
                            streamingContent.innerHTML += data.content;
                            fullReply += data.content;
                            scrollToBottom();
                        } else if (data.type === 'streaming_complete') {
                            // Streaming is complete, now process the full response
                            fullReply = data.full_reply;
                            
                            // Process the complete response with plots and formatting
                            try {
                                const processResponse = await fetch("{% url 'process_streamed_response' %}", {
                                    method: "POST",
                                    headers: {"Content-Type": "application/json"},
                                    body: JSON.stringify({
                                        full_reply: fullReply,
                                        session_id: sessionId
                                    })
                                });
                                
                                if (!processResponse.ok) {
                                    throw new Error(`Processing failed: HTTP ${processResponse.status}`);
                                }
                                
                                const processData = await processResponse.json();
                                
                                // Check if the response contains an error
                                if (processData.error) {
                                    throw new Error(`Processing error: ${processData.error}`);
                                }
                                
                                const enhancedReply = processData.reply;
                                const isJsonResponse = processData.is_json_response;
                            
                            let finalContent;
                            
                            if (isJsonResponse) {
                                // For JSON responses, the HTML is already formatted
                                finalContent = enhancedReply;
                                
                                // Process special elements that need JavaScript handling
                                // Increase timeout to ensure KaTeX is fully loaded
                                setTimeout(() => {
                                    // Check if KaTeX is available
                                    if (typeof katex === 'undefined') {
                                        console.error('KaTeX is not loaded!');
                                        return;
                                    }
                                    
                                    console.log('KaTeX is available, processing formulas...');
                                    
                                    // Handle LaTeX math formulas
                                    const mathElements = document.querySelectorAll('.math-formula');
                                    console.log(`Found ${mathElements.length} math elements`);
                                    
                                    mathElements.forEach((elem, index) => {
                                        let formula = elem.getAttribute('data-formula');
                                        console.log(`Processing formula ${index + 1}:`, formula);
                                        
                                        if (formula) {
                                            try {
                                                // Clean up the formula if it has the $$ wrapper
                                                formula = formula.replace(/^\$\$/, '').replace(/\$\$$/, '');
                                                console.log('Cleaned formula:', formula);
                                                
                                                const rendered = katex.renderToString(formula, { 
                                                    displayMode: true,
                                                    throwOnError: false,
                                                    strict: false
                                                });
                                                
                                                elem.innerHTML = rendered;
                                                console.log('Successfully rendered formula', index + 1);
                                            } catch (error) {
                                                console.error('KaTeX error for formula', index + 1, ':', error);
                                                console.error('Formula was:', formula);
                                                elem.innerHTML = `<div class="formula-error">Formula rendering failed: ${formula}<br>Error: ${error.message}</div>`;
                                            }
                                        } else {
                                            // Fallback: try to extract formula from the element content
                                            let content = elem.textContent || elem.innerText;
                                            console.log('No data-formula attribute, trying content:', content);
                                            
                                            if (content.includes('$$')) {
                                                const match = content.match(/\$\$(.*?)\$\$/);
                                                if (match) {
                                                    formula = match[1];
                                                    try {
                                                        console.log('Fallback rendering formula:', formula);
                                                        const rendered = katex.renderToString(formula, { 
                                                            displayMode: true,
                                                            throwOnError: false,
                                                            strict: false
                                                        });
                                                        elem.innerHTML = rendered;
                                                    } catch (error) {
                                                        console.error('KaTeX fallback error:', error);
                                                        elem.innerHTML = `<div class="formula-error">Formula rendering failed: ${formula}<br>Error: ${error.message}</div>`;
                                                    }
                                                }
                                            }
                                        }
                                    });
                                    
                                    // Table processing is now done on the backend
                                    // Just ensure tables have proper styling
                                    const tables = document.querySelectorAll('.table-container table');
                                    tables.forEach(table => {
                                        table.classList.add('formatted-table');
                                    });
                                    
                                    // Syntax highlighting for code blocks
                                    if (typeof Prism !== 'undefined') {
                                        Prism.highlightAll();
                                    }
                                }, 500);
                                
                            } else {
                                // For non-JSON responses, use the original processing logic
                            let processedReply = enhancedReply;
                            
                            // First, handle code blocks that contain markdown tables
                            processedReply = processedReply.replace(/```md\s*\n([\s\S]*?)\n```/g, (match, content) => {
                                return marked.parse(content);
                            });
                            
                            // Handle LaTeX math formulas wrapped in $$
                            processedReply = processedReply.replace(/\$\$([\s\S]*?)\$\$/g, (match, content) => {
                                try {
                                    return katex.renderToString(content, { displayMode: true });
                                } catch (error) {
                                    console.log('KaTeX error:', error);
                                    return `<pre><code class="language-latex">${content}</code></pre>`;
                                }
                            });
                            
                            // Parse the markdown first
                            let parsedReply = marked.parse(processedReply);
                            
                            // Handle code blocks with collapsible format
                            parsedReply = parsedReply.replace(/<pre><code class="language-(\w+)">([\s\S]*?)<\/code><\/pre>/g, (match, language, content) => {
                                const lang = language || 'text';
                                let displayTitle = lang;
                                let buttonText = 'Show Code';
                                
                                // Use proper titles for known languages
                                if (lang === 'python') {
                                    displayTitle = 'Plot Code';
                                    buttonText = 'Show Code';
                                } else if (lang === 'sql') {
                                    displayTitle = 'SQL Query';
                                    buttonText = 'Show Query';
                                }
                                
                                const uniqueId = 'code-' + Math.random().toString(36).substr(2, 9);
                                
                                let codeBlockHtml = `
                                    <div class="code-toggle-container">
                                        <button class="code-toggle-btn" onclick="toggleCodeSection('${uniqueId}', this)">${buttonText}</button>
                                    </div>
                                    <div class="code-block" id="${uniqueId}" style="display: none;">
                                        <div class="code-header">
                                            <span class="code-language">${displayTitle}</span>
                                            <button class="code-copy-btn" onclick="copyToClipboard(this, '${uniqueId}-content')">Copy</button>
                                        </div>
                                        <div class="code-content">
                                            <pre><code class="language-${lang}" id="${uniqueId}-content">${content}</code></pre>
                                        </div>
                                    </div>
                                `;
                                
                                return codeBlockHtml;
                            });
                                
                                finalContent = `<div class="markdown-content">${parsedReply}</div>`;
                            }
                            
                            // Replace the streaming content with the processed content
                            streamingElem.innerHTML = `
                                <div class="message-content">
                                    ${finalContent}
                                </div>
                            `;
                            
                            // Apply table folding to newly added content
                            setTimeout(() => {
                                const newTableSections = streamingElem.querySelectorAll('.table-section');
                                newTableSections.forEach(section => {
                                    const tableContainer = section.querySelector('.table-container');
                                    const toggleContainer = section.querySelector('.table-toggle-container');
                                    const toggleText = toggleContainer ? toggleContainer.querySelector('.table-toggle-text') : null;
                                    
                                    if (tableContainer && toggleContainer && toggleText) {
                                        const table = tableContainer.querySelector('table');
                                        if (table) {
                                            const rows = table.querySelectorAll('tbody tr');
                                            
                                            // Only show toggle button if table has more than 5 rows
                                            if (rows.length <= 5) {
                                                toggleContainer.style.display = 'none';
                                            } else {
                                                // Show only top 5 rows initially
                                                rows.forEach((row, index) => {
                                                    row.style.display = index < 5 ? '' : 'none';
                                                });
                                                // Set correct button text
                                                toggleText.innerHTML = '▼ Show Complete Table';
                                            }
                                        }
                                    }
                                });
                            }, 100);
                            
                            // CRITICAL: Initialize tabs for newly added Information sections
                            setTimeout(() => {
                                console.log('Initializing tabs for new content...');
                                const newTabSections = streamingElem.querySelectorAll('.combined-section');
                                newTabSections.forEach(section => {
                                    initializeTabSection(section);
                                });
                            }, 150);
                            
                            // Add feedback buttons outside the message bubble
                            const feedbackContainer = document.createElement('div');
                            feedbackContainer.className = 'feedback-buttons';
                            feedbackContainer.setAttribute('data-message-id', 'new');
                            feedbackContainer.innerHTML = `
                                <button class="feedback-btn like-btn" onclick="submitFeedback('like', ${sessionId}, 'new', event)" title="Like this response (click again to remove)">
                                    👍
                                </button>
                                <button class="feedback-btn dislike-btn" onclick="submitFeedback('dislike', ${sessionId}, 'new', event)" title="Dislike this response (click again to remove)">
                                    👎
                                </button>
                                <button class="faq-btn" onclick="addToFAQ(${sessionId}, 'new', event)" title="Add this conversation to FAQ" data-session-id="${sessionId}">
                                    Add to FAQ
                                </button>
                            `;
                            
                            // Insert feedback buttons after the message container
                            const messageContainer = streamingElem.closest('.message-container');
                            if (messageContainer) {
                                messageContainer.appendChild(feedbackContainer);
                            } else {
                                // Fallback to old method if container not found
                                streamingElem.parentNode.insertBefore(feedbackContainer, streamingElem.nextSibling);
                            }
                            
                            // Load feedback state for the new message after a longer delay to ensure DB save
                            setTimeout(() => {
                                loadExistingFeedback();
                            }, 500);
                            
                            scrollToBottom();
                            
                            } catch (processingError) {
                                console.error('Error processing response:', processingError);
                                hasError = true;
                                streamingElem.innerHTML = `
                                    <div class="message-content">
                                        <div class="error-message">
                                            <h4>⚠️ Response Processing Error</h4>
                                            <p>There was an issue processing the server response. This might be due to:</p>
                                            <ul>
                                                <li>Network timeout or connection issues</li>
                                                <li>Server overload or temporary unavailability</li>
                                                <li>Invalid JSON format in the response</li>
                                            </ul>
                                            <details>
                                                <summary>Technical Details</summary>
                                                <pre>${processingError.message}</pre>
                                                <p><strong>Raw Response:</strong></p>
                                                <pre>${fullReply.substring(0, 500)}${fullReply.length > 500 ? '...' : ''}</pre>
                                            </details>
                                            <p><em>Please try your question again. If the problem persists, consider rephrasing your query or trying again later.</em></p>
                                        </div>
                                    </div>
                                `;
                            }
                            
                        } else if (data.type === 'error') {
                            hasError = true;
                            streamingElem.innerHTML = `
                                <div class="message-content">
                                    <div class="error-message">
                                        <h4>❌ Server Error</h4>
                                        <p>The server encountered an error while processing your request:</p>
                                        <pre>${data.error}</pre>
                                        <p><em>Please try again. If the problem persists, the server may be experiencing high load.</em></p>
                                    </div>
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.error('Error parsing streaming data:', error, 'Line:', line);
                        // Don't show error for every parsing failure, as some lines might be incomplete
                    }
                }
            }
        }
        
    } catch (error) {
        console.error('Network/Connection Error:', error);
        const streamingElem = document.getElementById(streamingId);
        if (streamingElem) {
            let errorMessage = 'Unknown error occurred';
            let suggestions = [];
            
            if (error.name === 'AbortError') {
                errorMessage = 'Request timeout (10 minutes exceeded)';
                suggestions = [
                    'The server took too long to respond',
                    'Try a simpler question or break it into smaller parts',
                    'Check your internet connection',
                    'The server may be experiencing high load'
                ];
            } else if (error.message.includes('Failed to fetch')) {
                errorMessage = 'Network connection failed';
                suggestions = [
                    'Check your internet connection',
                    'The server may be temporarily unavailable',
                    'Try refreshing the page and trying again'
                ];
            } else if (error.message.includes('HTTP')) {
                errorMessage = `Server error: ${error.message}`;
                suggestions = [
                    'The server returned an error response',
                    'Try again in a few moments',
                    'If the problem persists, the server may be down for maintenance'
                ];
            } else {
                errorMessage = error.message || 'Unexpected error';
                suggestions = [
                    'Try refreshing the page',
                    'Check your internet connection',
                    'Try again with a different question'
                ];
            }
            
            streamingElem.innerHTML = `
                <div class="message-content">
                    <div class="error-message">
                        <h4>🔌 Connection Error</h4>
                        <p><strong>Error:</strong> ${errorMessage}</p>
                        <p>Possible solutions:</p>
                        <ul>
                            ${suggestions.map(s => `<li>${s}</li>`).join('')}
                        </ul>
                        <details>
                            <summary>Technical Details</summary>
                            <pre>Error Type: ${error.name || 'Unknown'}
Error Message: ${error.message || 'No message'}
Stack: ${error.stack ? error.stack.substring(0, 300) + '...' : 'Not available'}</pre>
                        </details>
                        <p><em>Please try your question again.</em></p>
                    </div>
                </div>
            `;
        }
    }
};

// Focus on input when page loads
userInput.focus();

// Load existing feedback state for messages
async function loadExistingFeedback() {
    try {
        const response = await fetch(`{% url 'get_feedback_state' current_session.id %}`);
        const data = await response.json();
        
        if (data.feedback_state && Object.keys(data.feedback_state).length > 0) {
            // Get all feedback containers
            const allFeedbackContainers = document.querySelectorAll('.feedback-buttons');
            
            // Get all bot messages
            const botMessages = document.querySelectorAll('.message-bot');
            
            // Match feedback containers with messages by position
            botMessages.forEach((message, index) => {
                const markdownContent = message.querySelector('.markdown-content');
                const messageId = markdownContent ? markdownContent.getAttribute('data-message-id') : null;
                
                if (messageId && data.feedback_state[messageId]) {
                    const feedbackType = data.feedback_state[messageId];
                    const feedbackContainer = allFeedbackContainers[index];
                    
                    if (feedbackContainer) {
                        const likeBtn = feedbackContainer.querySelector('.like-btn');
                        const dislikeBtn = feedbackContainer.querySelector('.dislike-btn');
                        
                        if (likeBtn && dislikeBtn) {
                            // Remove all active states first
                            likeBtn.classList.remove('active');
                            dislikeBtn.classList.remove('active');
                            
                            // Apply the correct active state
                            if (feedbackType === 'like') {
                                likeBtn.classList.add('active');
                            } else if (feedbackType === 'dislike') {
                                dislikeBtn.classList.add('active');
                            }
                        }
                    }
                }
            });
        }
    } catch (error) {
        console.error('Error loading feedback state:', error);
    }
}

// Process existing messages with markdown
function processExistingMessages() {
    const markdownContents = document.querySelectorAll('.markdown-content[data-text]');
    markdownContents.forEach(content => {
        const text = content.getAttribute('data-text');
        if (text) {
            // Decode Unicode escape sequences
            let decodedText = text.replace(/\\u([0-9a-fA-F]{4})/g, (match, hex) => {
                return String.fromCharCode(parseInt(hex, 16));
            });
            
            // Use the decoded text directly (plots are now embedded in the message)
            let messageText = decodedText;
            
            // First, handle code blocks that contain markdown tables
            messageText = messageText.replace(/```md\s*\n([\s\S]*?)\n```/g, (match, content) => {
                // Parse the content inside the code block as markdown
                return marked.parse(content);
            });
            
            // Handle LaTeX math formulas wrapped in $$
            messageText = messageText.replace(/\$\$([\s\S]*?)\$\$/g, (match, content) => {
                try {
                    return katex.renderToString(content, { displayMode: true });
                } catch (error) {
                    console.log('KaTeX error:', error);
                    return `<pre><code class="language-latex">${content}</code></pre>`;
                }
            });
            
            // Parse the markdown first
            let parsedText = marked.parse(messageText);
            
            // Handle code blocks with collapsible format
            parsedText = parsedText.replace(/<pre><code class="language-(\w+)">([\s\S]*?)<\/code><\/pre>/g, (match, language, content) => {
                const lang = language || 'text';
                let displayTitle = lang;
                let buttonText = 'Show Code';
                
                // Use proper titles for known languages
                if (lang === 'python') {
                    displayTitle = 'Plot Code';
                    buttonText = 'Show Code';
                } else if (lang === 'sql') {
                    displayTitle = 'SQL Query';
                    buttonText = 'Show Query';
                }
                
                const uniqueId = 'code-' + Math.random().toString(36).substr(2, 9);
                
                let codeBlockHtml = `
                    <div class="code-toggle-container">
                        <button class="code-toggle-btn" onclick="toggleCodeSection('${uniqueId}', this)">${buttonText}</button>
                    </div>
                    <div class="code-block" id="${uniqueId}" style="display: none;">
                        <div class="code-header">
                            <span class="code-language">${displayTitle}</span>
                            <button class="code-copy-btn" onclick="copyToClipboard(this, '${uniqueId}-content')">Copy</button>
                        </div>
                        <div class="code-content">
                            <pre><code class="language-${lang}" id="${uniqueId}-content">${content}</code></pre>
                        </div>
                    </div>
                `;
                
                return codeBlockHtml;
            });
            

            
            console.log('Decoded text:', decodedText);
            console.log('Parsed text:', parsedText);
            content.innerHTML = parsedText;
            
            // Render KaTeX in existing messages
            setTimeout(() => {
                renderMath();
            }, 100);
        }
    });
}

// Toggle code section visibility
function toggleCodeSection(codeId, button) {
    const codeBlock = document.getElementById(codeId);
    
    if (!codeBlock) {
        console.error('Code block not found:', codeId);
        return;
    }
    
    const isHidden = codeBlock.style.display === 'none' || !codeBlock.classList.contains('show');
    
    if (isHidden) {
        // Show the code block
        codeBlock.style.display = 'block';
        codeBlock.classList.add('show');
        
        // Update button text based on type
        if (button.textContent === 'Show Code') {
            button.textContent = 'Hide Code';
        } else if (button.textContent === 'Show Query') {
            button.textContent = 'Hide Query';
        }
    } else {
        // Hide the code block
        codeBlock.style.display = 'none';
        codeBlock.classList.remove('show');
        
        // Update button text based on type
        if (button.textContent === 'Hide Code') {
            button.textContent = 'Show Code';
        } else if (button.textContent === 'Hide Query') {
            button.textContent = 'Show Query';
        }
    }
}

// Copy code to clipboard
function copyToClipboard(button, elementId) {
    const element = document.getElementById(elementId);
    if (!element) {
        console.error('Element not found:', elementId);
        return;
    }
    
    const text = element.textContent || element.innerText;
    
    // Use the modern clipboard API if available
    if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
            // Visual feedback
            const originalText = button.textContent;
            button.textContent = '✓ Copied!';
            button.style.background = '#10b981';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '';
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy: ', err);
            fallbackCopyTextToClipboard(text, button);
        });
    } else {
        // Fallback for older browsers
        fallbackCopyTextToClipboard(text, button);
    }
}

// Fallback copy function for older browsers
function fallbackCopyTextToClipboard(text, button) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    
    // Avoid scrolling to bottom
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        const successful = document.execCommand('copy');
        if (successful) {
            // Visual feedback
            const originalText = button.textContent;
            button.textContent = '✓ Copied!';
            button.style.background = '#10b981';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '';
            }, 2000);
        } else {
            console.error('Fallback: Copying text command was unsuccessful');
        }
    } catch (err) {
        console.error('Fallback: Oops, unable to copy', err);
    }
    
    document.body.removeChild(textArea);
}

// Execute Python script function
async function executePythonScript(executionId, encodedScript, sessionId) {
    const scriptContent = decodeURIComponent(encodedScript);
    const resultDiv = document.getElementById(`result-${executionId}`);
    const plotContainer = document.getElementById(`plot-${executionId}`);
    const outputContainer = document.getElementById(`output-${executionId}`);
    const executeBtn = document.querySelector(`[data-execution-id="${executionId}"] .execute-python-btn`);
    
    // Show loading state
    executeBtn.textContent = '🔄 Executing...';
    executeBtn.disabled = true;
    resultDiv.style.display = 'block';
    plotContainer.innerHTML = '<div class="loading">Executing Python script...</div>';
    outputContainer.innerHTML = '';
    
    try {
        const response = await fetch("{% url 'execute_python_script' %}", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                script_content: scriptContent,
                session_id: sessionId
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Display the plot
            plotContainer.innerHTML = `
                <div class="plot-display">
                    <img src="${data.plot_url}" alt="Generated Plot" style="max-width: 100%; height: auto; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <button class="download-plot-btn" onclick="downloadPlot('${data.plot_url}', '${data.plot_filename}')">
                        📥 Download Plot
                    </button>
                </div>
            `;
            
            // Show execution output
            if (data.stdout) {
                outputContainer.innerHTML += `<div class="stdout"><strong>Output:</strong><pre>${data.stdout}</pre></div>`;
            }
            if (data.stderr) {
                outputContainer.innerHTML += `<div class="stderr"><strong>Errors:</strong><pre>${data.stderr}</pre></div>`;
            }
            
            executeBtn.textContent = '✅ Executed';
        } else {
            plotContainer.innerHTML = `<div class="error">❌ Error: ${data.error}</div>`;
            if (data.stdout) {
                outputContainer.innerHTML += `<div class="stdout"><strong>Output:</strong><pre>${data.stdout}</pre></div>`;
            }
            if (data.stderr) {
                outputContainer.innerHTML += `<div class="stderr"><strong>Errors:</strong><pre>${data.stderr}</pre></div>`;
            }
            executeBtn.textContent = '❌ Failed';
        }
    } catch (error) {
        plotContainer.innerHTML = `<div class="error">❌ Network Error: ${error.message}</div>`;
        executeBtn.textContent = '❌ Failed';
    }
}

// Download plot function
function downloadPlot(plotUrl, filename) {
    const link = document.createElement('a');
    link.href = plotUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Initialize tabs and content properly
function initializeTabs() {
    try {
        console.log('=== INITIALIZING TABS WITH NEW METHOD ===');
        
        // Find all tab sections
        const tabSections = document.querySelectorAll('.combined-section');
        console.log('Found tab sections:', tabSections.length);
        
        // Use the new section-specific initialization
        tabSections.forEach((section, index) => {
            console.log(`Initializing section ${index}:`);
            initializeTabSection(section);
        });
        
        // Also process any standalone math elements
        setTimeout(() => {
            renderMath();
            processSpecialElements();
        }, 500);
        
        console.log('=== TAB INITIALIZATION COMPLETE ===');
        
    } catch (error) {
        console.error('Error initializing tabs:', error);
    }
}

// Call on page load with a small delay to ensure DOM is ready
setTimeout(() => {
    processExistingMessages();
    loadExistingFeedback();
    updateFAQButtonStates();
    initializeTabs();
}, 500);

// Also call when DOM content is loaded
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        processExistingMessages();
        loadExistingFeedback();
        updateFAQButtonStates();
        initializeTabs();
    }, 100);
});

// Additional attempt after a longer delay to ensure everything is loaded
setTimeout(() => {
    processExistingMessages();
    loadExistingFeedback();
    updateFAQButtonStates();
    initializeTabs();
}, 1000);

// Add a manual refresh function for debugging
window.refreshFeedbackState = function() {
    console.log('Manual refresh of feedback state...');
    loadExistingFeedback();
};

// Add debugging functions for tabs
window.debugTabs = function() {
    console.log('=== TAB DEBUG INFO ===');
    const tabSections = document.querySelectorAll('.combined-section');
    console.log('Tab sections found:', tabSections.length);
    
    tabSections.forEach((section, sectionIndex) => {
        console.log(`Section ${sectionIndex}:`);
        const buttons = section.querySelectorAll('.tab-btn');
        const contents = section.querySelectorAll('.tab-content');
        
        console.log(`  Buttons: ${buttons.length}`);
        buttons.forEach((btn, i) => {
            console.log(`    Button ${i}: active=${btn.classList.contains('active')}, text="${btn.textContent}"`);
        });
        
        console.log(`  Contents: ${contents.length}`);
        contents.forEach((content, i) => {
            console.log(`    Content ${i}: id="${content.id}", display="${content.style.display}", visible=${content.offsetParent !== null}`);
        });
    });
    
    const mathElements = document.querySelectorAll('.math-formula');
    console.log('Math elements found:', mathElements.length);
    mathElements.forEach((elem, i) => {
        console.log(`  Math ${i}: processed=${elem.classList.contains('katex-processed')}, formula="${elem.getAttribute('data-formula')}"`);
    });
};

// Add manual tab initialization for debugging
window.reinitializeTabs = function() {
    console.log('Manual tab reinitialization...');
    initializeTabs();
};

// Feedback submission function
async function submitFeedback(feedbackType, sessionId, messageId, event) {
    try {
        const response = await fetch("{% url 'feedback' %}", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                feedback_type: feedbackType,
                session_id: sessionId,
                message_id: messageId
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Find the clicked button
            const clickedBtn = event.target;
            const feedbackContainer = clickedBtn.closest('.feedback-buttons');
            
            if (feedbackContainer) {
                const likeBtn = feedbackContainer.querySelector('.like-btn');
                const dislikeBtn = feedbackContainer.querySelector('.dislike-btn');
                
                // Remove all active states first
                likeBtn.classList.remove('active');
                dislikeBtn.classList.remove('active');
                
                // Apply the correct active state based on the response
                if (data.feedback_type === 'like') {
                    likeBtn.classList.add('active');
                } else if (data.feedback_type === 'dislike') {
                    dislikeBtn.classList.add('active');
                }
                
                // If this was a new message and feedback was added, update the message ID
                if (messageId === 'new' && data.message_id) {
                    feedbackContainer.setAttribute('data-message-id', data.message_id);
                }
            }
        } else {
            console.error('Feedback submission failed:', data.error);
        }
    } catch (error) {
        console.error('Error submitting feedback:', error);
    }
}

// Add to FAQ function
async function addToFAQ(sessionId, messageId, event) {
    try {
        const clickedBtn = event.target;
        const isInFAQ = clickedBtn.classList.contains('in-faq');
        const action = isInFAQ ? 'remove' : 'add';
        
        const response = await fetch("{% url 'add_to_faq' %}", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                session_id: sessionId,
                message_id: messageId,
                action: action
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Show success feedback
            const originalText = clickedBtn.textContent;
            const successText = action === 'add' ? '✅ Added to FAQ' : '✅ Removed from FAQ';
            clickedBtn.textContent = successText;
            clickedBtn.style.background = '#38a169';
            clickedBtn.disabled = true;
            
            // Update button state
            if (action === 'add') {
                clickedBtn.classList.add('in-faq');
                clickedBtn.textContent = 'Delete from FAQ';
                clickedBtn.style.background = '#e53e3e';
            } else {
                clickedBtn.classList.remove('in-faq');
                clickedBtn.textContent = 'Add to FAQ';
                clickedBtn.style.background = '#38a169';
            }
            
            // Reset button after 3 seconds
            setTimeout(() => {
                clickedBtn.disabled = false;
            }, 3000);
        } else {
            console.error('FAQ action failed:', data.error);
            // Show error feedback
            const originalText = clickedBtn.textContent;
            clickedBtn.textContent = '❌ Failed';
            clickedBtn.style.background = '#e53e3e';
            
            // Reset button after 3 seconds
            setTimeout(() => {
                clickedBtn.textContent = originalText;
                clickedBtn.style.background = isInFAQ ? '#e53e3e' : '#38a169';
            }, 3000);
        }
    } catch (error) {
        console.error('Error with FAQ action:', error);
        // Show error feedback
        const clickedBtn = event.target;
        const originalText = clickedBtn.textContent;
        clickedBtn.textContent = '❌ Error';
        clickedBtn.style.background = '#e53e3e';
        
        // Reset button after 3 seconds
        setTimeout(() => {
            clickedBtn.textContent = originalText;
            clickedBtn.style.background = clickedBtn.classList.contains('in-faq') ? '#e53e3e' : '#38a169';
        }, 3000);
    }
}

// Check FAQ status for a session
async function checkFAQStatus(sessionId) {
    try {
        const response = await fetch(`{% url 'check_faq_status' 0 %}`.replace('0', sessionId));
        const data = await response.json();
        
        if (data.success) {
            return data.is_in_faq;
        }
    } catch (error) {
        console.error('Error checking FAQ status:', error);
    }
    return false;
}

// Update FAQ button states for all messages
async function updateFAQButtonStates() {
    const faqButtons = document.querySelectorAll('.faq-btn');
    for (const btn of faqButtons) {
        const sessionId = btn.getAttribute('data-session-id');
        if (sessionId) {
            const isInFAQ = await checkFAQStatus(sessionId);
            if (isInFAQ) {
                btn.classList.add('in-faq');
                btn.textContent = 'Delete from FAQ';
                btn.style.background = '#e53e3e';
            } else {
                btn.classList.remove('in-faq');
                btn.textContent = 'Add to FAQ';
                btn.style.background = '#38a169';
            }
        }
    }
}

// NEW FUNCTIONS FOR RESTRUCTURED LAYOUT

// Note: Toggle functions removed as copy buttons now work directly

// Toggle table expansion (show only top 5 rows vs complete table)
function toggleTable(tableId) {
    const tableContainer = document.getElementById(tableId);
    const toggleContainer = event.currentTarget;
    const toggleText = toggleContainer.querySelector('.table-toggle-text');
    const table = tableContainer.querySelector('table');
    
    if (!table) return;
    
    const rows = table.querySelectorAll('tbody tr');
    const isExpanded = toggleText.textContent.includes('Show Top 5');
    
    if (isExpanded) {
        // Show only top 5 rows
        rows.forEach((row, index) => {
            row.style.display = index < 5 ? '' : 'none';
        });
        toggleText.innerHTML = '▼ Show Complete Table';
    } else {
        // Show all rows
        rows.forEach(row => {
            row.style.display = '';
        });
        toggleText.innerHTML = '▲ Show Top 5 Rows';
    }
}

// Initialize tabs for a specific section (fixes interference between multiple sections)
function initializeTabSection(section) {
    console.log('Initializing tab section:', section);
    
    // Find tab buttons and contents within this specific section
    const tabButtons = section.querySelectorAll('.tab-btn');
    const tabContents = section.querySelectorAll('.tab-content');
    
    if (tabButtons.length === 0 || tabContents.length === 0) {
        console.log('No tabs found in section');
        return;
    }
    
    // Hide all tab contents
    tabContents.forEach(content => {
        content.style.display = 'none';
    });
    
    // Remove active class from all buttons
    tabButtons.forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show first tab and make its button active
    if (tabContents[0] && tabButtons[0]) {
        tabContents[0].style.display = 'block';
        tabButtons[0].classList.add('active');
        console.log('Activated first tab:', tabButtons[0].textContent);
    }
    
    // Add click handlers to tab buttons (section-specific)
    tabButtons.forEach((button, index) => {
        // Remove any existing onclick handlers to prevent conflicts
        button.onclick = function(event) {
            event.preventDefault();
            switchTabInSection(section, index, event);
        };
    });
}

// Section-specific tab switching (prevents interference between multiple Information sections)
function switchTabInSection(section, tabIndex, event) {
    console.log('Switching to tab:', tabIndex, 'in section:', section);
    
    // Find tab buttons and contents within this specific section only
    const tabButtons = section.querySelectorAll('.tab-btn');
    const tabContents = section.querySelectorAll('.tab-content');
    
    // Hide all tab contents in this section
    tabContents.forEach(content => {
        content.style.display = 'none';
    });
    
    // Remove active class from all tab buttons in this section
    tabButtons.forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show selected tab content and activate button
    if (tabContents[tabIndex] && tabButtons[tabIndex]) {
        tabContents[tabIndex].style.display = 'block';
        tabButtons[tabIndex].classList.add('active');
        
        console.log('Switched to tab:', tabButtons[tabIndex].textContent);
        
        // Process LaTeX formulas if switching to formulas tab
        if (tabButtons[tabIndex].textContent.trim().includes('Formulas')) {
            setTimeout(() => processSpecialElements(tabContents[tabIndex]), 100);
        } else {
            setTimeout(() => renderMath(tabContents[tabIndex]), 100);
        }
    }
}

// Switch tabs in combined information section
function switchTab(tabId, clickedButton = null, messageId = null) {
    try {
        console.log('Switching to tab:', tabId);
        
        const scope = messageId ? document.querySelector(`[data-message-id='${messageId}']`) : document;

        // Hide all tab contents
        const allTabContents = scope.querySelectorAll('.tab-content');
        allTabContents.forEach(content => {
            content.style.display = 'none';
        });
        
        // Remove active class from all tab buttons
        const allTabButtons = scope.querySelectorAll('.tab-btn');
        allTabButtons.forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Show selected tab content
        const selectedContent = scope.querySelector(`#${tabId}`);
        if (selectedContent) {
            selectedContent.style.display = 'block';
            console.log('Showed tab content for:', tabId);
        } else {
            console.error('Tab content not found for:', tabId);
            return;
        }
        
        // Add active class to clicked button
        const buttonToActivate = clickedButton || event?.target || scope.querySelector(`[onclick*="${tabId}"]`);
        if (buttonToActivate) {
            buttonToActivate.classList.add('active');
            console.log('Activated button for tab:', tabId);
        }
        
        // Process content based on tab type
        setTimeout(() => {
            if (tabId === 'formulas') {
                console.log('Processing formulas tab...');
                processSpecialElements();
            } else if (tabId === 'definitions' || tabId === 'steps') {
                console.log('Processing text content for tab:', tabId);
                // Ensure any markdown or special content is processed
                renderMath();
            }
        }, 100);
        
    } catch (error) {
        console.error('Error in switchTab:', error);
    }
}

// Process special elements like LaTeX formulas
function processSpecialElements() {
    // Check if KaTeX is available
    if (typeof katex === 'undefined') {
        console.error('KaTeX is not loaded!');
        return;
    }
    
    console.log('Processing special elements (formulas)...');
    
    // Handle LaTeX math formulas
    const mathElements = document.querySelectorAll('.math-formula');
    console.log(`Found ${mathElements.length} math elements to process`);
    
    mathElements.forEach((elem, index) => {
        const formula = elem.getAttribute('data-formula');
        if (formula && !elem.classList.contains('katex-processed')) {
            try {
                console.log(`Rendering formula ${index + 1}:`, formula);
                
                // Clean the formula - remove any existing $$ wrappers
                let cleanFormula = formula.replace(/^\$\$/, '').replace(/\$\$$/, '');
                
                const rendered = katex.renderToString(cleanFormula, { 
                    displayMode: true,
                    throwOnError: false,
                    strict: false
                });
                
                elem.innerHTML = rendered;
                elem.classList.add('katex-processed');
                console.log(`Successfully rendered formula ${index + 1}`);
                
            } catch (error) {
                console.error(`Error rendering formula ${index + 1}:`, error);
                // Fallback: show the raw formula
                elem.innerHTML = `<pre><code class="language-latex">${formula}</code></pre>`;
            }
        }
    });
}

// Render math formulas in existing content
function renderMath() {
    // Check if KaTeX is available
    if (typeof katex === 'undefined') {
        console.error('KaTeX is not loaded for renderMath!');
        return;
    }
    
    console.log('Rendering math in existing content...');
    
    // Process math formulas in the current visible content
    const mathElements = document.querySelectorAll('.math-formula:not(.katex-processed)');
    console.log(`Found ${mathElements.length} unprocessed math elements`);
    
    mathElements.forEach((elem, index) => {
        const formula = elem.getAttribute('data-formula');
        if (formula) {
            try {
                console.log(`Rendering existing formula ${index + 1}:`, formula);
                
                // Clean the formula
                let cleanFormula = formula.replace(/^\$\$/, '').replace(/\$\$$/, '');
                
                const rendered = katex.renderToString(cleanFormula, { 
                    displayMode: true,
                    throwOnError: false,
                    strict: false
                });
                
                elem.innerHTML = rendered;
                elem.classList.add('katex-processed');
                console.log(`Successfully rendered existing formula ${index + 1}`);
                
            } catch (error) {
                console.error(`Error rendering existing formula ${index + 1}:`, error);
                elem.innerHTML = `<pre><code class="language-latex">${formula}</code></pre>`;
            }
        }
    });
    
    // Also process any inline LaTeX that might exist
    processInlineMath();
}

// Process inline math formulas
function processInlineMath() {
    // Find any remaining $$ wrapped content that wasn't processed
    const textNodes = document.evaluate(
        '//text()[contains(., "$$")]',
        document.body,
        null,
        XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
        null
    );
    
    for (let i = 0; i < textNodes.snapshotLength; i++) {
        const node = textNodes.snapshotItem(i);
        if (node.nodeValue && node.nodeValue.includes('$$')) {
            try {
                const parent = node.parentNode;
                if (parent && !parent.classList.contains('katex-processed')) {
                    const text = node.nodeValue;
                    const processed = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, formula) => {
                        try {
                            return katex.renderToString(formula, { displayMode: true });
                        } catch (error) {
                            console.log('Inline KaTeX error:', error);
                            return match; // Return original if error
                        }
                    });
                    
                    if (processed !== text) {
                        const wrapper = document.createElement('span');
                        wrapper.innerHTML = processed;
                        wrapper.classList.add('katex-processed');
                        parent.replaceChild(wrapper, node);
                    }
                }
            } catch (error) {
                console.error('Error processing inline math:', error);
            }
        }
    }
}

// Initialize table folding on page load
document.addEventListener('DOMContentLoaded', function() {
    // Auto-fold tables to show only top 5 rows initially
    setTimeout(() => {
        const tableSections = document.querySelectorAll('.table-section');
        tableSections.forEach(section => {
            const tableContainer = section.querySelector('.table-container');
            const toggleContainer = section.querySelector('.table-toggle-container');
            const toggleText = toggleContainer ? toggleContainer.querySelector('.table-toggle-text') : null;
            
            if (tableContainer && toggleContainer && toggleText) {
                const table = tableContainer.querySelector('table');
                if (table) {
                    const rows = table.querySelectorAll('tbody tr');
                    
                    // Only show toggle button if table has more than 5 rows
                    if (rows.length <= 5) {
                        toggleContainer.style.display = 'none';
                    } else {
                        // Show only top 5 rows initially
                        rows.forEach((row, index) => {
                            row.style.display = index < 5 ? '' : 'none';
                        });
                        // Set correct button text
                        toggleText.innerHTML = '▼ Show Complete Table';
                    }
                }
            }
        });
    }, 1000);
});
</script>
{% endblock %}